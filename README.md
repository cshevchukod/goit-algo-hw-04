# goit-algo-hw-04

## Завдання
Порівняти швидкість 3 алгоритмів сортування за допомогою `timeit`:
- Merge Sort (злиттям)
- Insertion Sort (вставками)
- TimSort (`sorted()` у Python)

## Запуск
```bash
python main.py
```

## Дані для тестів
- random
- sorted
- reversed
- almost_sorted (~1% перестановок)

Розміри: 100, 500, 1000, 2000, 5000

## Результати
=== Dataset: random ===
n       insertion       merge   timsort
100     0.000110        0.000339        0.000003
500     0.002944        0.001882        0.000010
1000    0.013905        0.003825        0.000020
2000    0.056379        0.007757        0.000042
5000    0.353318        0.021190        0.000274

=== Dataset: sorted ===
n       insertion       merge   timsort
100     0.000010        0.000328        0.000002
500     0.000031        0.001749        0.000003
1000    0.000069        0.003473        0.000005
2000    0.000130        0.007018        0.000011
5000    0.000320        0.018471        0.000020

=== Dataset: reversed ===
n       insertion       merge   timsort
100     0.000216        0.000330        0.000002
500     0.005919        0.001697        0.000003
1000    0.025950        0.003539        0.000007
2000    0.105722        0.007126        0.000009
5000    0.701656        0.018660        0.000018

=== Dataset: almost_sorted ===
n       insertion       merge   timsort
100     0.000005        0.000053        0.000000
500     0.000087        0.000341        0.000003
1000    0.000333        0.000779        0.000007
2000    0.001446        0.001786        0.000016
5000    0.009430        0.005054        0.000037

## Висновки
- Insertion sort швидко стає повільним на random/reversed, бо має O(n²) у середньому/найгіршому випадку.
- Merge sort стабільний для більших n: O(n log n).
- TimSort (sorted) зазвичай найшвидший на практиці, особливо на частково відсортованих даних.
